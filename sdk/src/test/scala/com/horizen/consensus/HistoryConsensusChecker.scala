package com.horizen.consensus

import java.util
import java.util.Random

import com.horizen.block.SidechainBlock
import com.horizen.companion.SidechainTransactionsCompanion
import com.horizen.fixtures._
import com.horizen.params.{NetworkParams, TestNetParams}
import com.horizen.storage.{InMemoryStoreAdapter, SidechainHistoryStorage}
import com.horizen.transaction.TransactionSerializer
import com.horizen.validation.ConsensusValidator
import com.horizen.{SidechainHistory, SidechainTypes}
import org.junit.Test
import scorex.core.block.Block

import scala.collection.mutable
import scala.util.{Failure, Success, Try}


class HistoryConsensusChecker {

  def createHistory(params: NetworkParams, genesisBlock: SidechainBlock): SidechainHistory = {
    val companion: SidechainTransactionsCompanion = SidechainTransactionsCompanion(new util.HashMap[java.lang.Byte, TransactionSerializer[SidechainTypes#SCBT]]())

    val sidechainHistoryStorage: SidechainHistoryStorage = new SidechainHistoryStorage(new InMemoryStoreAdapter(), companion, params)
    SidechainHistory.genesisHistory(sidechainHistoryStorage, new ConsensusDataStorage(new InMemoryStoreAdapter()), params, genesisBlock, Seq(), Seq(new ConsensusValidator())).get
  }

  def generateBlock(generationRule: GenerationRules, generator: SidechainBlocksGenerator, finishEpochOp: (Block.BlockId, FinishedEpochInfo) => Unit): (Seq[SidechainBlocksGenerator], SidechainBlock) = {
    val (nextGenerator, generationResult) = generator.tryToGenerateBlock(generationRule)
    generationResult match {
      case Right(generatedBlockInfo) => (Seq(nextGenerator), generatedBlockInfo.block)
      case Left(finishedEpochInfo) => {
        finishEpochOp(nextGenerator.lastBlockId, finishedEpochInfo)
        val (nextNextGenerator, firstEpochBlockGenerationInfo) = nextGenerator.tryToGenerateBlock(generationRule.copy(mcReferenceIsPresent = Some(true)))
        (Seq(nextGenerator, nextNextGenerator), firstEpochBlockGenerationInfo.right.get.block)
      }
    }
  }

  private def historyOperationOnEpochEnd(history: SidechainHistory)(lastBlockId: Block.BlockId, finishEpochOp: FinishedEpochInfo): Unit = {
    history.applyStakeConsensusEpochInfo(lastBlockId, finishEpochOp.stakeConsensusEpochInfo)
    println(s"//////////////// Epoch ${lastBlockId} had been ended ////////////////")
  }

  private def historyUpdateShallBeSuccessful(history: SidechainHistory, newBlock: SidechainBlock): SidechainHistory = {
    println(s"append to History: ${newBlock.id}")
    history.append(newBlock) match {
      case Failure(ex) => {
        println(s"Got exception during add block ${newBlock.id} to the history: ${ex.getMessage}")
        throw ex
      }
      case Success(historyWithBlock) => historyWithBlock._1
    }
  }

  private def historyUpdateShallBeFailed(history: SidechainHistory, newBlock: SidechainBlock, incorrectGenerationRules: GenerationRules): Unit = {
    history.append(newBlock) match {
      case Failure(ex) => {
        println(s"Got expected exception during add block ${newBlock.id} to the history: ${ex.getMessage}")
      }
      case Success(historyWithBlock) => throw new IllegalStateException(s"Incorrect block generated by ${incorrectGenerationRules} had been successfully added")
    }
  }

  private def generatorSelection(rnd: Random, generators: mutable.IndexedSeq[SidechainBlocksGenerator]): SidechainBlocksGenerator = {
    @scala.annotation.tailrec
    def generatorSelectionIteration(rnd: Random, index: Int, generators: mutable.IndexedSeq[SidechainBlocksGenerator]): SidechainBlocksGenerator = {
      if (index == 0) {
        generators(0)
      }
      else {
        if (rnd.nextBoolean()) {
          println()
          println(s"return ${index} generator from ${generators.size - 1}")
          generators(index)
        }
        else {
          generatorSelectionIteration(rnd, index - 1, generators)
        }
      }
    }
    generatorSelectionIteration(rnd, generators.size - 1, generators)
  }


  //@Test
  def testWithSeed(testSeed: Int): Unit = {
    //val testSeed = 234
    val rnd: Random = new Random(testSeed)

    val initialParams = TestNetParams(consensusSlotsInEpoch = 10, sidechainGenesisBlockTimestamp = 1333344452L)
    val (params, genesisBlock, genesisGenerator, genesisForgingData, genesisEndEpochInfo) = SidechainBlocksGenerator.startSidechain(1000000L, testSeed, initialParams)
    val history: SidechainHistory = createHistory(params, genesisBlock)
    history.applyStakeConsensusEpochInfo(genesisBlock.id, genesisEndEpochInfo.stakeConsensusEpochInfo)
    println(s"//////////////// Genesis epoch ${genesisBlock.id} had been ended ////////////////")

    val historyUpdateAtEpochEnd = historyOperationOnEpochEnd(history) _

    val generators = mutable.IndexedSeq(genesisGenerator)


    (1 to 3000)
      .foldLeft[(SidechainHistory, mutable.IndexedSeq[SidechainBlocksGenerator])]((history, generators)) { (acc, index) =>
        val currentHistory: SidechainHistory = acc._1
        val currentGenerators: mutable.IndexedSeq[SidechainBlocksGenerator] =  acc._2

        val nextGenerator: SidechainBlocksGenerator = generatorSelection(rnd, currentGenerators)
        val nextCorrectGenerationRules: GenerationRules = GenerationRules.generateCorrectGenerationRules(rnd, nextGenerator)
        val nextIncorrectGenerationRules: GenerationRules = CorruptedGenerationRules.corruptGenerationRules(rnd, params, nextGenerator, nextCorrectGenerationRules)

        Try(generateBlock(nextIncorrectGenerationRules, nextGenerator, historyUpdateAtEpochEnd)) match {
          case Success((gens, generatedBlock)) => historyUpdateShallBeFailed(currentHistory, generatedBlock, nextIncorrectGenerationRules)

          case Failure(ex) =>
            println("Error during incorrect block generation")
        }

        println()

        Try(generateBlock(nextCorrectGenerationRules, nextGenerator, historyUpdateAtEpochEnd)) match {
          case Success((gens, generatedBlock)) =>
            val updatedHistory = historyUpdateShallBeSuccessful(currentHistory, generatedBlock)
            val updatedGenerators = currentGenerators ++ gens
            (updatedHistory, updatedGenerators)

          case Failure(ex: GenerationIsNoLongerPossible) =>
            println("Finishing block generation")
            return

          case Failure(ex) =>
            println("Error during block generation")
            throw ex
        }
      }
  }

  @Test
  def testManySeeds(): Unit = {
    val seed = 908

    (50 to 50).map{index =>
      println(s"SEED IS ${index}")
      testWithSeed(index + seed)
    }
  }

}
