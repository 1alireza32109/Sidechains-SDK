package com.horizen

import java.io.{File, FileOutputStream}
import java.net.{InetSocketAddress, URL}
import java.lang.{Byte => JByte, Long => JLong}
import java.util.{ArrayList => JArrayList, HashMap => JHashMap}

import javafx.util.{Pair => JPair}
import com.typesafe.config.{Config, ConfigFactory}
import net.ceedubs.ficus.Ficus._
import net.ceedubs.ficus.readers.ArbitraryTypeReader._
import com.horizen.block.{SidechainBlock, SidechainBlockSerializer}
import com.horizen.box.{NoncedBox, RegularBox}
import com.horizen.companion.SidechainTransactionsCompanion
import com.horizen.params.MainNetParams
import com.horizen.proof.Signature25519
import com.horizen.proposition.{Proposition, PublicKey25519Proposition}
import com.horizen.secret.{PrivateKey25519, PrivateKey25519Creator}
import com.horizen.transaction.{RegularTransaction, SidechainTransaction, TransactionSerializer}
import com.horizen.utils.BytesUtils
import scorex.core.settings.{ScorexSettings, SettingsReaders}
import scorex.core.settings.ScorexSettings.readConfigFromPath
import scorex.util.ScorexLogging
import scorex.util._

case class WebSocketClientSettings(
                                    remoteAddress: InetSocketAddress = new InetSocketAddress("127.0.0.1", 8888),
                                    connectionTimeout : Long = 5000,
                                    connectionTimeUnit :String = "MILLISECONDS")

case class SidechainSettings(val config: Config, scorexSettings: ScorexSettings, webSocketClientSettings: WebSocketClientSettings) {

  protected val sidechainTransactionsCompanion: SidechainTransactionsCompanion = SidechainTransactionsCompanion(new JHashMap[JByte, TransactionSerializer[SidechainTypes#SCBT]]())

  //TODO this implementation is for test only
  val genesisKey = PrivateKey25519Creator.getInstance().generateSecret("genesis_seed123".getBytes)

  val sctestNode0Key = PrivateKey25519Creator.getInstance().generateSecret("node0".getBytes)
  val sctestNode1Key = PrivateKey25519Creator.getInstance().generateSecret("node1".getBytes)
  val sctestNode2Key = PrivateKey25519Creator.getInstance().generateSecret("node2".getBytes)

  val nodeKey = {
    if (scorexSettings.network.nodeName.equals("testNode1"))
      PrivateKey25519Creator.getInstance().generateSecret("target1".getBytes)
    else if (scorexSettings.network.nodeName.startsWith("node"))
      scorexSettings.network.nodeName match {
        case "node0" => sctestNode0Key
        case "node1" => sctestNode1Key
        case "node2" => sctestNode2Key
      }
    else
      PrivateKey25519Creator.getInstance().generateSecret(Random.randomBytes())
  }

  private def getGenesisTransactions: Seq[SidechainTransaction[Proposition, NoncedBox[Proposition]]] = {
    val fee = 0
    val timestamp = 1547798549470L

    val from = new JArrayList[JPair[RegularBox, PrivateKey25519]]
    val to = new JArrayList[JPair[PublicKey25519Proposition, JLong]]

    val creator = PrivateKey25519Creator.getInstance

    from.add(new JPair[RegularBox, PrivateKey25519](new RegularBox(genesisKey.publicImage, 1, 400000L), genesisKey))

    to.add(new JPair[PublicKey25519Proposition, JLong](nodeKey.publicImage, 100000L))
    to.add(new JPair[PublicKey25519Proposition, JLong](sctestNode0Key.publicImage, 100000L))
    to.add(new JPair[PublicKey25519Proposition, JLong](sctestNode1Key.publicImage, 100000L))
    to.add(new JPair[PublicKey25519Proposition, JLong](sctestNode2Key.publicImage, 100000L))

    val transaction = RegularTransaction.create(from, to, fee, timestamp)
    val id = transaction.id
    Seq(transaction.asInstanceOf[SidechainTransaction[Proposition, NoncedBox[Proposition]]])
  }

  val genesisBlock : Option[SidechainBlock] = Some(
    new SidechainBlockSerializer(sidechainTransactionsCompanion).parseBytes(
      // Hex representation of Sidehcain block generated by commented code below and above.
      BytesUtils.fromHexString("0000000000000000000000000000000000000000000000000000000000000000aaf3d3d40b0200f40402ee04010000000000000000000001685ffb93de0000003202603cfbf879f515ff96c9031ebcbc006170dd6c30522a35d488c7472c4a75dc114800000000000000010000000000061a80000000850840404040bf126e8d1db806f1b7d6ec11449c7c9218228c80675c8a46ebcef53b57c4ee40360abecb5072917bd8450254f79a1b8dc2082141d3750cc2be0f705fc564164f9a82fe816fb6f5eb81fc99f229ab02ce33104f13b0c996670a19e105ca679c158f1afa41ca33e1d7aa5c2588691f5021fc6b2c2b3420a65b040985d957b6bf3100000000000186a000000000000186a000000000000186a000000000000186a0000000430280017fc877ee966cbb5165ea9ce1ce9be95a8b7e36063ad4e8c2e2ba43561bf881cbe469f6d4711ffa9604f86afc2bdf44fead82d8c66d18911d45da6bec681547063cfbf879f515ff96c9031ebcbc006170dd6c30522a35d488c7472c4a75dc114806f7945809641437ef7bff46a5a2351a7acefe5aecf4c325b90a5c65446fd08dc2a0cb153421b37a5a0dc24773e56eaeabb2f43f82ed1d8c33c932e7180b7709")
    )
  )

  /*
  val genesisBlock : Option[SidechainBlock] = SidechainBlock.create(
    SidechainSettings.genesisParentBlockId,
    1565162709L, // Wednesday, August 7, 2019 7:25:09 AM
    Seq(),
    getGenesisTransactions,
    genesisKey,
    sidechainTransactionsCompanion,
    new MainNetParams(),
    None
  ).toOption

  val genesisBlockBytes = BytesUtils.toHexString(new SidechainBlockSerializer(sidechainTransactionsCompanion).toBytes(genesisBlock.get))
  */
}

object SidechainSettings
  extends ScorexLogging
    with SettingsReaders
{

  protected val sidechainSettingsName = "sidechain-sdk-settings.conf"
  val genesisParentBlockId : scorex.core.block.Block.BlockId = bytesToId(new Array[Byte](32))

  def read(userConfigPath: Option[String]): SidechainSettings = {
    fromConfig(readConfigFromPath(userConfigPath))
  }

  private def fromConfig(config: Config): SidechainSettings = {
    val webSocketClientSettings = config.as[WebSocketClientSettings]("scorex.websocket")
    val scorexSettings = config.as[ScorexSettings]("scorex")
    SidechainSettings(config, scorexSettings, webSocketClientSettings)
  }

  def readConfigFromPath(userConfigPath: Option[String]): Config = {

    val userConfigFile: Option[File] = userConfigPath.map(filename => new File(filename)).filter(_.exists())
    val userConfigResource: Option[URL] = userConfigPath.map(filename => getClass.getClassLoader.getResource(filename))

    val userConfig: Option[Config] = if (userConfigFile.isDefined) {
      Some(ConfigFactory.parseFile(userConfigFile.get))
    } else if (userConfigResource.isDefined) {
      Some(ConfigFactory.parseURL(userConfigResource.get))
    } else None

    val config = userConfig match {
      case Some(cfg) => ConfigFactory
        .defaultOverrides()
        .withFallback(cfg) // user-supplied config
        .withFallback(ConfigFactory.defaultApplication())
        .withFallback(ConfigFactory.parseResources(sidechainSettingsName))
        .withFallback(ConfigFactory.defaultReference()) // "src/main/resources/reference.conf"
        .resolve()
      case None => {
        log.warn("NO CONFIGURATION FILE WAS PROVIDED. STARTING WITH DEFAULT SETTINGS!")
        ConfigFactory
          .defaultOverrides()
          .withFallback(ConfigFactory.defaultApplication())
          .withFallback(ConfigFactory.parseResources(sidechainSettingsName))
          .withFallback(ConfigFactory.defaultReference()) // "src/main/resources/reference.conf"
          .resolve()
      }
    }

    config
  }
}